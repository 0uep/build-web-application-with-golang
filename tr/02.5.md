# Nesne-Yönelim

Son iki bölüm de fonksiyonlar ve `struct` hakkında konuştuk, ancak fonksiyonları `struct` ın bir alanı olarak kullanmayı düşündünüz mü? Bu bölümde, alıcısı olan `method` olarak adlandırılan başka bir fonksiyon biçimi tanıtacağım.

## method

Bir "Dikdortgen" struct tanımladığınızı ve onun alanını hesaplamak istediğinizi varsayalım. Bu amaca ulaşmak için genellikle aşağıdaki kodu kullanırdık.
```Go
package main

import "fmt"

type Dikdortgen struct {
	genislik, yukseklik float64
}

func alan(r Dikdortgen) float64 {
	return r.genislik * r.yukseklik
}

func main() {
	d1 := Dikdortgen{12, 2}
	d2 := Dikdortgen{9, 4}
	fmt.Println("d1 in alanı: ", alan(d1))
	fmt.Println("d2 nin alanı: ", alan(d2))
}

```
Yukarıdaki örnek bir Dikdortgen'in alanını hesaplayabilir. Burada `alan` isimli fonksiyonu kullanıyoruz, fakat bu fonksiyon Dikdortgen struct'ının bir method u değil(klasik nesne yönelimli dillerdeki sınıf nethodları gibi). Fark edebileceğiniz gibi fonksiyon ve struct iki bağımsız şeydir.

Şimdiye kadar sorun değil. Bununla birlikte, bir dairenin, karenin, beşgenin veya başka herhangi bir şeklin alanını da hesaplamanız gerekiyorsa, çok benzer adlara sahip ek fonksiyonlar eklemeniz gerekecektir.

![](images/2.5.rect_func_without_receiver.png?raw=true)

Figure 2.8 Fonksiyon ve struct arasındaki ilişki

Açıkçası bu hiç hoş değil. Ayrıca, alan fonksiyonu bir dairenin veya dikdörtgenin özelliği olmalıdır.

İşte `method` un devreye gireceği nokta burasıdır. `method`, bir türe/tipe bağlı fonksiyondur. `func` anahtar sözcüğünün, bu methodun ana gövdesi olan `receiver` adlı bit parametreye sahip olması haricinde, fonksiyonlar benzer bir sözdizimi vardır.

Aynı örneği kullanarak, `Dikdortgen.Alan()` çevresel bir fonksiyon yerine doğrudan Dikdortgen'e aittir. Daha spesifik olarak, `yukseklik`, `genislik` ve `Alan()` hepsi Dikdortgen'e aittir.

Rob Pike'ın dediği gibi.

	"Bir method, alıcı olarak adlandırılan ilk örtülü argüman olan bir fonksiyondur."

method sözdimi.
```Go
func (r ReceiverType) funcName(parameters) (results)
```
Örneğimizi `method` kullanarak değiştirelim.
```Go
package main

import (
	"fmt"
	"math"
)

type Daire struct {
	yaricap float64
}

type Dikdortgen struct {
	genislik, yukseklik float64
}

// method
func (daire Daire) Alan() float64 {
	return daire.yaricap * daire.yaricap * math.Pi
}

// method
func (dikdortgen Dikdortgen) Alan() float64 {
	return dikdortgen.genislik * dikdortgen.yukseklik
}

func main() {
	daire1 := Daire{10}
	daire2 := Daire{25}
	dikdortgen1 := Dikdortgen{9, 4}
	dikdortgen2 := Dikdortgen{12, 2}

	fmt.Println("daire1 in alanı: ", daire1.Alan())
	fmt.Println("daire2 nin alanı: ", daire2.Alan())
	fmt.Println("dikdortgen1 in alanı: ", dikdortgen1.Alan())
	fmt.Println("dikdortgen2 nin alanı: ", dikdortgen2.Alan())
}
```

Methodları kullanma notları.

- Methodların adı aynıysa ancak aynı alıcıları paylaşmıyorlarsa, aynı değildirler.
- Methodlar alıcılardaki alanlara erişebilirler.
- Bir `struct` da method çağırmak için `.` kullanın, aynı şekilde alanları da çağırabilirsiniz.

![](images/2.5.shapes_func_with_receiver_cp.png?raw=true)

Figure 2.9 Methodlar farklı struct larda farklıdırlar.

Yukarıdaki örnakte Alan() methodu hem Dikdortgen hem de Daire'de mevcuttur, bu nedenle alıcıları Dikdortgen ve Daire'dir.

One thing that's worth noting is that the method with a dotted line means the receiver is passed by value, not by reference. The difference between them is that a method can change its receiver's values when the receiver is passed by reference, and it gets a copy of the receiver when the receiver is passed by value.

Alıcı sadece bir struct'mı olmalıdır? Tabii ki değil. Herhangibir tür/tip methodun alıcısı olabilir. Özelleştirilmiş türler/tipler hakkında kafanız karışabilir. struct özel bir tür/tip dir - daha birçok özelleştirilmiş tür/tip yer almaktadır.

Özelleştirilmiş bir tür/tip tanımlamak için aşağıdaki formatı kullanın.
```Go
type typeName typeLiteral
```
Özelleştirilmiş türler/tipler e örnekler:

```Go
type yas int
type fiyat float32
type aylar map[string]int

a := aylar {
	"Ocak":31,
	"Şubat":28,
	...
	"Aralık":31,
}
```

Özelleştirilmiş türlerin/tiplerin artık nasıl kullanılacağını biliyorsunuz. C programlama dilindeki `typedef` ifadesine benzer bir şekilde, yukarıdaki örnekte `int` yerine `yas` kullanıyoruz.

`method` hakkında konuşmaya geri dönelim.

Özelleştirilmiş türler/tipler de istediğiniz kadar method kullanabilirsiniz.
```Go
package main

import "fmt"

const (
	BEYAZ = iota
	SIYAH
	MAVI
	KIRMIZI
	SARI
)

type Kutu struct {
	genislik, yukseklik, derinlik float64
	renk Renk
}
type Renk byte
type KutuListesi []Kutu //kutu listesi

// method
func (kutu Kutu) Hacim() float64 {
	return kutu.genislik * kutu.yukseklik * kutu.derinlik
}

// işaretçi alıcılı method
func (k *Kutu) RenkAta(r Renk) {
	k.renk = r
}

// method
func (kl KutuListesi) EnBuyuklerininRengi() Color {
	h := 0.00
	r := Renk(BEYAZ)
	for _, k := range kl {
		if k.Hacim() > h {
			h = k.Hacim()
			r = k.renk
		}
	}
	return k
}

// method
func (kl KutuListesi) SiyahaBoya() {
	for i, _ := range kl {
		kl[i].RenkAta(SIYAH)
	}
}

// method
func (r Renk) String() string {
	strings := []string{"BEYAZ", "SIYAH", "MAVI", "KIRMIZI", "SARI"}
	return strings[r]
}

func main() {
	kutular := KutuListesi{
		Kutu{4, 4, 4, KIRMIZI},
		Kutu{10, 10, 1, SARI},
		Kutu{1, 1, 20, SIYAH},
		Kutu{10, 10, 1, MAVI},
		Kutu{10, 30, 1, BEYAZ},
		Kutu{20, 20, 20, SARI},
	}

	fmt.Printf("%d adet kutumuz var\n", len(kutular))
	fmt.Println("İlk kutunun hacmi ", kutular[0].Hacim(), "cm³")
	fmt.Println("Son kutunun rengi", kutular[len(kutular)-1].renk.String())
	fmt.Println("En büyük kutu", kutular.EnBuyuklerininRengi().String())

	// Hepsini siyaha boyayalım
	boxes.SiyahaBoya()

	fmt.Println("İkinci kutunun rengi", kutular[1].renk.String())
	fmt.Println("En büyüğü", kutular.EnBuyuklerininRengi().String())
}
```

Bazı sabitleri ve özelleştirilmiş tür/tipleri tanımlarız

- `Renk` 'i `byte` 'ın takma adı olarak kullanın.
- Hacim, yukseklik, genislik, derinlik ve renk alanlarını içeren `Kutu` struct ını tanımlayın.
- `Kutu` yu alanı olarak alan  `KutuListesi` strruct ı tanımlayın.

Daha sonra özelleştirilmiş türlerimiz/tiplerimiz için bazı methodlar tanımladık.

- `Hacim()` uses Kutu as its receiver and returns the volume of Kutu.
- `RenkAta(c Color)` changes Box's color.
- `EnBuyuklerininRengi()` returns the color which has the biggest volume.
- `SiyahaBoya()` sets color for all Box in KutuListesi to SIYAH.
- `String()` use Color as its receiver, returns the string format of color name.

Is it much clearer when we use words to describe our requirements? We often write our requirements before we start coding.

### Use pointer as receiver

Let's take a look at `RenkAta` method. Its receiver is a pointer of Box. Yes, you can use `*Box` as a receiver. Why do we use a pointer here? Because we want to change Box's color in this method. Thus, if we don't use a pointer, it will only change the value inside a copy of Box.

If we see that a receiver is the first argument of a method, it's not hard to understand how it works.

You might be asking why we aren't using `(*b).Color=c` instead of `b.Color=c` in the `RenkAta()` method. Either one is OK here because Go knows how to interpret the assignment. Do you think Go is more fascinating now?

You may also be asking whether we should use `(&bl[i]).RenkAta(SIYAH)` in `SiyahaBoya` because we pass a pointer to `RenkAta`. Again, either one is OK because Go knows how to interpret it!

### Inheritance of method

We learned about inheritance of fields in the last section. Similarly, we also have method inheritance in Go. If an anonymous field has methods, then the struct that contains the field will have all the methods from it as well.
```Go
package main

import "fmt"

type Human struct {
	name  string
	age   int
	phone string
}

type Student struct {
	Human  // anonymous field
	school string
}

type Employee struct {
	Human
	company string
}

// define a method in Human
func (h *Human) SayHi() {
	fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

func main() {
	sam := Employee{Human{"Sam", 45, "111-888-XXXX"}, "Golang Inc"}
	mark := Student{Human{"Mark", 25, "222-222-YYYY"}, "MIT"}

	sam.SayHi()
	mark.SayHi()
}
```
### Method Overriding

If we want Employee to have its own method `SayHi`, we can define a method that has the same name in Employee, and it will hide `SayHi` in Human when we call it.
```Go
package main

import "fmt"

type Human struct {
	name  string
	age   int
	phone string
}

type Student struct {
	Human
	school string
}

type Employee struct {
	Human
	company string
}

func (h *Human) SayHi() {
	fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

func (e *Employee) SayHi() {
	fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name,
		e.company, e.phone) //Yes you can split into 2 lines here.
}

func main() {
	sam := Employee{Human{"Sam", 45, "111-888-XXXX"}, "Golang Inc"}
	mark := Student{Human{"Mark", 25, "222-222-YYYY"}, "MIT"}

	sam.SayHi()
	mark.SayHi()
}

```
You are able to write an Object-oriented program now, and methods use rule of capital letter to decide whether public or private as well.

## Links

- [Rehber](preface.md)
- Önceki bölüm: [struct](02.4.md)
- Sonraki bölüm: [interface](02.6.md)
